# Mathe Grundlagen

## Begriffe

**teilerfremd** = **relativ prim** = wenn es keine nat√ºrliche Zahl au√üer der 
                  Eins gibt, die beide Zahlen teilt
 
**prime Restklassengruppe** = $Z^*_m$ z.B. $Z^*_7 = \{ 1,2,3,4,5,6 \}$ oder 
                              $ Z^*_8 = \{ 1, 3, 5, 7 \} $ 
 
**abelsche Gruppe** = es gilt zus√§tzlich das Kommutativgesetz 
                    = **kommutative Gruppe**
 
**Homomorphismen** = ??
 
**Halbgruppe** = z.B. $S = (S, ‚äõ)$ Assoziativit√§t muss gelten, 
                 aber **kein** neutrales Element oder Inverse
 
**Ring** = $(R, +, ‚ãÖ)$ wobei $(R, +)$ abelsche Gruppe und 
           $(R, ‚ãÖ)$ eine Halbgruppe
 
**Restklasse** = Schreibweise: [a], bei $ ‚Ñ§_3 = \{ 0, 1, 2 \} $ gibt es drei 
                 Restklassen 
                 $[0] = \{... ,-3, 0, 3, ...\}; [1] = \{..., -2, 1, 4, ...\}$
 
**zyklische Gruppe** = z.B. $G = (M, ‚ãÖ_7)$ und $M={ Z^*_7 }$. 
                       Es gibt ein erzeugendes Element in M z.B. $‚ü®3‚ü©$, so dass 
                       jedes Element von M erreicht werden kann mit 
                       $ 3^n \mod 7 $ wobei $ n ‚àà ‚Ñ§ $. 
                       Es hei√üt zyklisch weil mit einem gewissen n sich die 
                       Zahlen wiederholen. 
                       In diesem Beispiel: 3 (n=1), 2 (n=2), 6 (n=3), 4, 5, 
                       1, 3, ...
 
Kommentar: Um zu pr√ºfen, ob ein Element ein erzeugendes Element von der Gruppe
           ist, siehe Diffie Hellmann.

 
##Gruppen auf endlichen Mengen

Eine Gruppe ist: Eine Menge + EIN bin√§rer Operator wo die 4 Axiome gelten.

4 Axiome:
 * bin√§re Verkn√ºpfung assoziativ $a ‚ó¶ (b ‚ó¶ c) = (a ‚ó¶ b) ‚ó¶ c$
 * Abgeschlossen $a‚ó¶b$
 * enth√§lt ein neutrales Element $a ‚ó¶ e = a$
 * F√ºr jedes a gibt es ein a' (Inverses) 
   $a ‚ó¶ a ‚Ä≤ = e$; z.B. G = (M, ‚äï) oder G = (M, ‚äõ)

**Beispiel**: $G = (M, ‚äõ)$ wobei $M = ‚Ñ§^*_m, ‚äõ = ‚ãÖ_m$   
              ($‚ãÖ_m$ bedeutet "mal modulo m")
 
**Kommentar**: $Z^*_m$ sind alle Teilerfremden Zahlen zu m. 
               Bei Primzahlen sind dies alle Zahlen von 1 bis Primzahl-1. 
               Bei anderen Zahlen sind es weniger z.B. 
               $ Z^*_8 = \{ 1, 3, 5, 7 \} $. 
 
**Begriffe:**
 - *Ordnung der Gruppe*: Anzahl der Elemente der Gruppe; $ ord(G) = |M| $

**Gibt es multiplikatives Inverses herausfinden:** 
  ggT(a, m) = 1, dann gibt es Inverses (Also a und m teilerfremd). 
  Euklidischer Algo.
 
**Multiplikative Inverses berechnen:** Jedes a' austesten oder erweiterter 
  Euklidischer Algo oder Satz nach Euler.
 
**Pre-Kommentar**: ggT (a, b) = Œ≥ ¬∑ a + Œ¥ ¬∑ b   (Jeder ggT(a, b) l√§sst sich 
  als Linearkombination darstellen)
 
**Erweiterter Euklidischer Algo:**
Ziel ist es die Linearkombination von ggT(a, b) herausfinden. Man spricht auch 
von der Linearfaktorzerlegung.

| a    | b               | $ \lfloor\frac{a}{b}\rfloor $ | d    | x                   | y                                         |
| ---- | --------------- | ----------------------------- | ---- | ------------------- | ----------------------------------------- |
| 102  | 75              | 1                             | 3    | -11                 | 15                                        |
| 75   | 102 mod 75 = 27 | 2                             | 3    | 4                   | -11                                       |
| 27   | 21              | 1                             | 3    | -3                  | 4                                         |
| 21   | 6               | 3                             | 3    | 1                   | -3                                        |
| 6    | 3               | 2                             | 3    | 0  (y von Reihe -1) | 1 ($ x - \lfloor\frac{a}{b}\rfloor * y $) |
| 3    | 0               | -                             | 3    | 1                   | 0                                         |

**L√∂sung:** ggT(102, 75) = 3 = 102 * (-11) + 75 * 15  
            Inverse zu **a ist x** und zu **b ist y** -> wenn es negativ ist 
            einfach + den Modulo rechnen damit es in die Zahlenmenge passt.
 
**Kommentar:** Die Variable d merkt sich das Ergebnis des ggT wenn der 
               erweiterte Euklid wieder R√ºckw√§rts l√§uft.

**Eulerische Œ¶ Funktion:** 
  Anzahl der Teilerfremdenzahlen. 
  z.B. $ Œ¶(6) = 2 $ oder $ Œ¶(7) = 6 $.
  Es gilt $ Œ¶(p) = p ‚àí 1 $ wenn p prim. 
  $Œ¶(p ‚ãÖ q) = (p ‚àí 1) ‚ãÖ (q - 1) $ wenn p, q prim und p ‚â† q
  (meistens irgendwie anwendbar)
 
**Satz von Euler:** $ a^{Œ¶(n)} = 1 \mod n $ wobei n eine nat√ºrliche Zahl ist. 
a > 0 und ggT(n, a) = 1. Somit fast immer anwendbar wenn n Prim ist.
$ a^{Œ¶(n)} = a^{p-1} \mod p $ f√ºr a > 0 und p Prim 
 
*Formel f√ºr das Inverse:*
$ a^{-1} = a^{Œ¶(n)-1} \mod n$ f√ºr a > 0 und ggt(n, a) = 1
 
**Berechne Multiplikative Inverse mit Satz von Euler:**
Wir haben eine multiplikative Gruppe mit $ M = Z^*_7 $. 
Wir suchen das Inverse von 3. Also nach Satz von Euler: 
$ 3^{Œ¶(7)-1} \mod 7 = 3^5 \mod 7 = 5 $ -> Inverse ist 5
-> Dies ist sehr effizient, solange wir Primzahlen verwenden. 
-> Wenn die Gruppe jedoch ein Modulo hat, welches nicht eine Primzahl ist, 
dann wird die Berechnung von der Phi Funktion komplizierter 
-> Eine Primfaktorzerlegung ist notwendig z.B. $ Œ¶(10) = (2-1) * (5-1) = 4 $
 
**Satz von Fermat:** Ist eine Aussage √ºber die Eigenschaft von Primzahlen. 
$ a^p ‚â° a \mod p $
$ a^{p-1} ‚â° 1 \mod p $  (im Prinzip dasselbe wie der Satz von Euler!! 
Deswegen wird der Satz von Euler auch Satz von Euler-Fermat genannt)
 
**Zu merken:** 

Satz von Fermat-Euler: $ a^{Œ¶(n)} = 1 \mod n $

Satz von Fermat-Euler Inverse berechnen: $ a^{-1} = a^{Œ¶(n)-1} \mod n $ 
wenn ggt(a, n) = 1 und a > 0, hei√üt a kann alles sein, wenn n prim, sonst kann 
man halt nicht alle Zahlen f√ºr a verwenden.
Wenn der Exponent gro√ü, dann kann die Exponentation in beliebig kleine 
Portitionen geteilt werden, alla modulare Exponentation. 
$ 11^{51} = 11^5 * 11^5 .... $ oder $ 11^{16} = 11^{2^{4}}  $.

 
## K√∂rper bzw. endliche Zahlenk√∂rper (Galios-Feld)

Ein K√∂rper ist eine Menge mit zwei Verkn√ºpfungen ‚äï und ‚äõ und 3 Axiome:

3 Axiome:

- $ (K, ‚äï) $ ist eine abelsche Gruppe/kommutative Gruppe mit neutralem Element 0
- $ (K \setminus \{0\}, ‚äõ) $ ist eine abelsche Gruppe/kommutative Gruppe mit
  neutralem Element 1
- Distributivgesetz gilt: $ a ‚ãÖ (b + c) = a ‚ãÖ b + a ‚ãÖ c $

Ein schnelle Schreibweise f√ºr die Gruppe ist z.B. GF(2). Die Menge ist dann 
$ \{0, 1\} $. Mit Primzahlen geht das immer, also allgemein GF(p).
 

## Hashfunktionen

**erstes Urbild Problem**: Nur der Hash-Wert ist gegeben und man versucht 
irgendein Urbild zu finden.

**zweites Urbild Problem**: Sowohl das 1. Urbild, als auch der Hashwert sind 
gegeben und man versucht ein 2. Urbild zu finden. 

***Kollisionsprobleme:***
 - **schwache kollisionsresistente Hashfunktionen / zweites Urbild Problem:** Wenn man beim Angriff das 1. Urbild und den Hash-Wert gegeben hat und man versucht das 2. Urbild zu finden. (selbe wie zweites Urbild Kollisionsresistenz)
 - **stark kollisionsresistente Hashfunktionen:** Wenn man beim Angriff das erste und zweite Urbild frei w√§hlen kann, um f√ºr beide den Selben Hash-Wert zu bekommen.

-> Wenn man √ºber einer der letzten beiden Angriffe eine Kollision findet, spricht man von einer Kollision.

**diskreter Logarithmus als Hashfunktion:** $ y = a^x \mod p $



## Vertraulichkeit, Integrit√§t und Authentizit√§t

Authentizit√§t einer Nachricht setzt ihre Integrit√§t voraus.

## Klassische Angriffe

Ciphertext-only-Angriff: 
  Bruteforce den Schl√ºssel raten. Bei Schw√§chen, wie z.B. 
  Redundanz -> Sprachliche Statistik muss nurnoch ein kleinerer Schl√ºsselraum 
  durchsucht werden.

Known-Plaintext-Angriff: 
 Dasselbe wie Ciphertext only nur das man nun das was rauskommen soll schon 
 wei√ü und vergleichen kann.

Choosen-Plaintext-Angriff:
  Wenn man den Plaintext kennt und man Zugriff auf 
  den Verschl√ºsselungsmethode, dann versucht man wiederum Wege zu finden 
  einen Brute Force Angriff zu vereinfachen.

Choosen-Ciphertext-Angriff: 
  bekannten Geheimtext mit unbekannten Schl√ºssel entschl√ºsseln, um wieder 
  schauen ob sich der Brute Force Angriff vereinfachen l√§sst.

 
## Klassische Chiffren

Substitutions Chiffren:
  Die Klartext Zeichen werden durch andere ersetzt. 
  Position bleibt die Selbe.

Transposition Chiffren:
  Die Position der Zeichen wird ver√§ndert, aber die Zeichen bleiben dieselben. 

Monoalphabetische Chiffre: 
  Jeder Selbe Klartext-Zeichen wird zum Selben Geheimtext-Zeichen.

Polyalphabetische Chiffre: 
  Mehrere Monoalphabetische Chiffren, um dies zu verhindern. 
  (Man weist z.B. demselben Buchstaben der h√§ufig vorkommt mehr Zahlen zu.)

Symmetrisch:
 - **Caesar Chiffre / Verschiebechiffre / ROT13 / Additive Chiffre**: ROT13 
   beliebt, da man einfach (bei 26 Buchstaben) beim nochmaligen verschl√ºsseln, 
   den Klartext wieder herausbekommt.
 - **Multiplikative Chiffre:** Funktioniert nur wenn alle Zeilen Teilerfremd 
   zum Modulo sind.
 - **One-Time-Pad:** Schl√ºssel genauso lang wie Klartext, streng zuf√§llig, 
   nur einmal verwenden. Additive Chiffre.
 - **Skytale:** Transpositionschiffre...
 

## Diffie-Hellmann-Schl√ºsselvereinbarung

Alice und Bob einigen sich auf eine 
**sichere Primzahl p (mit Einsatz einer kleinen Untergruppe)** und ein 
**erzeugendes Element ùõÇ**.

**Sichere Primzahl:** Eine Primzahl mit der Eigenschaft $ p = 2‚ãÖq+1 $, 
wobei q prim.
Eine sichere Primzahl vereinfacht die Pr√ºfung von ùõÇ ob es ein erzeugendes 
Element ist (sonst nicht trivial). Dazu muss man die Primfaktorzerlegung von 
Œ¶(p) kennen. Dies ist trivial f√ºr eine sichere Primzahl, da die 
Primfaktorzerlegung von Œ¶(p) = p-1 = 2‚ãÖq ist. 
Der Nachteil ist der Aufwand der modularen Exponentation von 
3n/2 Multiplikationen bei einer n-Bit Primzahl. Den Aufwand kann man minimieren,
wenn man stattdessen eine Primzahl mit der Eigenschaft $ p = N ‚ãÖ q + 1 $ w√§hlt.
Siehe *Sichere Primzahl mit Einsatz einer kleinen Untergruppe*.

**Erzeugendes Element / Generator**: $ ùõÇ ‚àà ‚Ñ§^*_p $ ist ein Generator, wenn 
$ ùõÇ^{Œ¶(p)/p_i} \mod p ‚â† 1 $, f√ºr jeden Primteiler $ p_i $ von Œ¶(p) stimmt. 
Primteiler sind die Primzahlen in der Primfaktorzerlegung von Œ¶(p). 
Die Primteiler sind 2 und q, da p eine sichere Primzahl ist. 
Der Algorithmus generiert, also solange zuf√§llige Zahlen zwischen 2 und p-1 bis
die Rechnung f√ºr alle Primteiler gilt. Beispiel sichere Primzahl 11 (2 * 5 + 1).
Zuf√§llige Zahl 3: $ 3^{10/2} \mod 11 = 1 $ -> kein Generator. 
Zuf√§llige Zahl 5: $ 5^{10/2} \mod 11 = 1 $ -> kein Generator. 
Zuf√§llige Zahl 8: $ 8^{10/2} \mod 11 = 10 ‚â† 1 $ ‚úîÔ∏é
, $ 8^{10/5} \mod 11 = 9 ‚â† 1 $ ‚úîÔ∏é
-> 8 bzw. $‚ü®8‚ü©$ ist ein Generator bzw. ein erzeugendes Element von 
$  ‚Ñ§^*_{11}  $. Nochmal zum Pr√ºfen: 8 (n=1), 9, 6, 4, 10, 3, 2, 5, 7, 1, 8, .... 

Kommentar: Generator pr√ºfen geht auch mit nicht sicheren Primzahlen bzw. 
Teilerfremde Zahlen zu n, also $ ùõÇ ‚àà ‚Ñ§^*_n $, aber die Primfaktorzerlegung ist 
dann nicht mehr trivial. 

**Generierung einer sicheren Primzahl:** Einfach normal zuf√§llige Primzahl 
generieren und pr√ºfen (MillerRabinTest) und anschlie√üend * 2 + 1 rechnen und 
nochmal Pr√ºfen ob das Ergebnis eine Primzahl ist bis beide eine Primzahl sind. 
Eine einfache Pr√ºfung ist, ob die Zahl ungerade ist und dann einen 
MillerRabinTest durchf√ºhren.

**Sichere Primzahl mit Einsatz einer kleinen Untergruppe:** 
Man kann den Aufwand der modularen Exponentation veringern, 
indem man eine Primzahl mit der Eigenschaft: 
$ p = N ‚ãÖ q + 1 $ w√§hlt, wobei $ 2^{255} < q < 2^{256} $ und N eine 
gro√üe Gerade Zahl. Anschlie√üend generiert man zuf√§llig eine 
Zahl a ‚àà {1, 2, ..., p-1} und berechnet das erzeugende 
Element $ ùõÇ = a^N \mod p $, solange bis $ ùõÇ \mod p ‚â† 1 $ und $ ùõÇ^q \mod p = 1 $. 

Alice und Bob einigen sich auf sehr gro√üe Primzahl p, sowie einer Primwurzel 
g von p, welche zu p-1 teilerfremd ist.

geheimen Zufallszahlen a und b erzeugt
 
$ x = g^a mod p $

$ y = g^b mod p $

$ k = y^a mod p $

$ k' = x^b mod p $

$ k = k' $

 
## RSA

Definition: 

$ ùí´ = ùíû = ‚Ñ§_n $
 
$ ùí¶ = \{(n,p,q,e,d) | n = p‚ãÖq, wobei\ p, q\ prim, e‚ãÖd‚â°1 \mod Œ¶(n)\} $
 
Schl√ºssel k = (n, p, q, e, d) ‚àà ùí¶
 - √ñffentlicher Teil: (n, e)
 - Privater Teil: (p, q, d)

Verschl√ºsselung: $ enc(k, x) = x^e \mod n $

Entschl√ºsselung: $ dec(k, y) = y^d \mod n $

Vorgehen: Bob w√§hlt p und q (mindestens 2048 bit pro Primzahl und p!=q und 
nicht zu Nahe beeinander) und berechnet n sowie Œ¶(n) einfach. 
Jetzt w√§hlt Bob ein e ‚àà {1, 2, . . . , Œ¶(n) ‚àí 1}, zuf√§llig und pr√ºft, 
das gcd(e, Œ¶(n)) = 1 und berechnet dabei gleichzeitig das Inverse von e und 
zwar d mit dem erweiterten Euklid.

Sicherheit basiert auf: Faktorisierungsproblem und das Problem zum Invertieren
der modularen Potenzfunktion

Effiziente Entschl√ºsselung (Garners Verfahren):

$ a = y^d \mod p $

$ b = y^d \mod q $

$ x = (((a -b)‚ãÖ(q^{-1} \mod p)) \mod p ) ‚ãÖ q + b $

M√∂glich ist Faktorisierung von n bei bekanntem 
Œ¶(n) -> Gleichungssystem, dann Mitternachtsformel.
$ p_{1,2} = \frac{-b ¬± \sqrt{b^2-4ac}}{b} $ 
-> a = 1, b = Œ¶(n) ‚àí n ‚àí 1, c = n -> wenn l√∂sbar, dann sind 
$ p_1 $ und $ p_2 $ die beiden Faktoren.

Wiener Attacke:
Funktioniert, wenn p und q zu Nahe beieinander sind (q < p < 2q)
und die Bin√§rdarstellung von d weniger als ‚Ñì/4 ‚àí 1 Bits gro√ü ist. 
(‚Ñì ist die L√§nge der Bin√§rdarstellung von n) ($ 3d < n ^{1/4}) $
dann kann man mit endlichen Kettenbr√ºchen n herausfinden.
-> .......

Highest Order Bit Attacke:
-> diese ist nur hypothetisch m√∂glich, wenn eine Methode half(y) = ... 
effizient berechnet werden k√∂nnte.

 
## ElGamal

$ ùí´ = ‚Ñ§_p $

$ ùíû = ‚Ñ§_p \times ‚Ñ§_p $

$ ùí¶ = \{(p, ùõÇ, d, e) | 2 ‚â§ d ‚â§ p-2, e ‚â° ùõÇ^d \mod p\} $

Schl√ºssel k = (p, ùõÇ, d, e)
 - √ñffentlicher Teil: (p, ùõÇ, e)
 - Privater Teil: d

$ enc(k, x) = y_1, y_2 $ wobei $ y_1 = ùõÇ^z \mod p $ und $ y_2 = x‚ãÖe^z \mod p $ 
f√ºr eine zuf√§llige, geheime Zahl $ z ‚àà Z^*_{p-1} $

$ dec(k, (y_1, y_2)) = y_2(y^d_1)^{-1} \mod p $

Schl√ºsselgenerierung: Wir w√§hlen eine Primzahl p und ein erzeugendes 
Element ùõÇ von $ Z^*_p $ und es wird der Rest berechnet 
$ e = ùõÇ^d \mod p $ wobei d der geheime Teil ist.  2 ‚â§ d ‚â§ p-2. 

Verschl√ºsselung: Man w√§hlt Nachricht x < p und w√§hlt eine Zufallszahl k, die 
teilerfremd zu p - 1 sein muss. Dann berechnet man $ y_1 $ und $ y_2 $.

Entschl√ºsselung: $ y^d_1 $ berechnen, dann das Inverse bilden und, dann 
$ y_2(y^d_1)^{-1} \mod p $ berechnen.

